1번 문제 설명
XX쇼핑센터는 다음과 같이 회원 등급제를 운영하고 있습니다.

등급	기준
브론즈	최근 30일간 0원 이상 10,000원 미만 구매 고객
실버	최근 30일간 10,000원 이상 20,000원 미만 구매 고객
골드	최근 30일간 20,000원 이상 50,000원 미만 구매 고객
플래티넘	최근 30일간 50,000원 이상 100,000원 미만 구매 고객
다이아몬드	최근 30일간 100,000원 이상 구매 고객
등급은 브론즈 → 실버 → 골드 → 플래티넘 → 다이아몬드 순으로 높아집니다.

고객의 2019년 1월 1일 ~ 2019년 12월 31일 기간 동안 구매 기록이 문자열 형태로 담긴 배열 purchase가 매개변수로 주어질 때, 각 등급별 유지 기간을 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
purchase의 길이는 1 이상 365 이하입니다.
purchase의 원소는 "2019/MM/DD X" 형식입니다.
2019/MM/DD는 2019년 MM월 DD일을 의미하며, "2019/01/01"에서 "2019/12/31"사이입니다.
구매 기록은 날짜 순으로 정렬되어 있습니다.
같은 날짜의 구매 기록이 중복해서 주어지지 않습니다.
'X'는 구매 금액을 나타내며 1,000 이상 200,000 이하인 자연수입니다.
구매 금액은 1,000원 단위로만 주어집니다.
정답 배열은 [브론즈 기간, 실버 기간, 골드 기간, 플래티넘 기간, 다이아몬드 기간] 순서로 채워서 return 해주세요.
입출력 예
purchase	result
["2019/01/01 5000", "2019/01/20 15000", "2019/02/09 90000"]	[315, 9, 11, 20, 10]
["2019/01/30 5000", "2019/04/05 10000", "2019/06/10 20000", "2019/08/15 50000", "2019/12/01 100000"]	[245, 30, 30, 30, 30]
입출력 예 설명
입출력 예 #1

2019년 1월 1일에 회원 가입한 고객의 구매 기록과 이에 따른 등급 변화입니다.

날짜	구매 금액(원)
1월 1일	5,000
1월 20일	15,000
2월 9일	90,000
예를 들어 1월 30일은 1월 1일 ~ 1월 30일까지 30일간 총 구매 금액이 20,000원이므로 골드 등급이며, 1월 31일은 30일간 총 구매 금액이 15,000원으로 실버 등급이 됩니다.

1월 1일 ~ 1월 19일은 브론즈 등급입니다.(19일)
1월 20일 ~ 1월 30일은 골드 등급입니다.(11일)
1월 31일 ~ 2월 8일은 실버 등급입니다. (9일)
2월 9일 ~ 2월 18일은 다이아 등급입니다. (10일)
2월 19일 ~ 3월 10일은 플래티넘 등급입니다. (20일)
3월 11일 ~ 12월 31일은 브론즈 등급입니다. (296일)
따라서 각 등급별 유지 기간은 [315일, 9일, 11일, 20일, 10일]입니다.

입출력 예 #2

각 등급별 유지 기간은 [245일, 30일, 30일, 30일, 30일]입니다.

-----------------------------------------

2번 문제 설명

바둑판에 가로, 세로, 대각선으로 n개의 돌이 연속해서 나열되어 있을 때를 ’n목’이라고 합니다. 단, 연속으로 나열된 돌이 n개보다 많다면 이는 n목으로 취급하지 않습니다.
아래 그림은 7 X 9 크기의 바둑판에 n = 4일때의 n목을 타원으로 표시한 것입니다. 돌이 있는 칸에는 1, 없는 칸에는 0이 적혀있습니다.
pic.png

가로 4목은 5개, 세로 4목은 1개, 대각선 4목은 4개이므로 4목은 10개입니다. 녹색 사각형으로 표시된 부분은 돌이 5개 연속으로 나열되어 있으므로, 4목으로 취급하지 않습니다.

바둑판의 세로크기 h, 가로크기 w, n목을 정의하는 숫자 n, 바둑판을 나타내는 배열 board가 주어졌을 때, n목의 개수를 return 하도록 solution 함수를 완성해 주세요.

제한사항
h, w, n은 4이상 1000이하인 자연수입니다.
board의 길이는 h입니다.
board의 원소는 길이가 w인 문자열입니다.
문자열은 0과 1로만 구성됩니다.
1은 돌이 놓인 칸을, 0은 돌이 없는 칸을 나타냅니다.
입출력 예
h	w	n	board	result
7	9	4	["111100000","000010011","111100011","111110011","111100011","111100010","111100000"]	10
5	5	5	["11111","11111","11111","11111","11111"]	12
입출력 예 설명
입출력 예 #1
앞서 설명한 예와 같습니다.

입출력 예 #2
가로로 5개, 세로로 5개, 대각선으로 2개씩 5목을 만들 수 있으므로 정답은 12입니다.

--------------------------------------------

3번 문제 설명

아래 그림과 같이 한 칸이 1 x 1 크기 정사각형으로 이루어진 4 x 4 크기 정사각 격자의 행, 열을 규칙에 따라 움직이려 합니다.

grid_1.png

행을 이동하는 규칙은 다음과 같습니다.

행을 하나 선택합니다.
선택한 행을 오른쪽(또는 왼쪽)으로 한 칸씩 이동합니다.
가장 오른쪽(또는 가장 왼쪽)에 있는 칸은 선택한 행의 반대편 칸으로 이동합니다.
열을 이동하는 규칙은 다음과 같습니다.

열을 하나 선택합니다.
선택한 열을 아래쪽(또는 위쪽)으로 한 칸씩 이동합니다.
가장 아래쪽(또는 위쪽)에 있는 칸은 선택한 열의 반대편 칸으로 이동합니다.
다음 그림은 위 규칙에 따라 1행을 왼쪽으로 한 칸씩 이동시킨 결과를 나타냅니다.

grid_2.png

위 그림에서 1행의 2,3,4열이 왼쪽으로 한 칸씩 이동했으며, 가장 왼쪽 칸이 반대편으로 이동한 것을 확인할 수 있습니다.

칸을 이동할 행과 열을 선택하는 데는 제한이 없으며, 한번 이동한 행, 열 또한 몇 번이라도 선택하여 이동할 수 있습니다.

다음 그림은 동일한 행을 여러 번 이동하는 예시입니다.

grid_3.png

다음 그림은 행과 열을 적절히 이동시켜 격자를 처음 상태로 만드는 예시입니다.

grid_4.png

현재 격자의 상태가 담긴 2차원 정수 배열 grid가 매개변수로 주어질 때, 격자를 처음 상태로 만들기 위해 행, 열을 이동하는 최소 횟수를 return 하도록 solution 함수를 완성해주세요.

여기서 격자의 처음 상태란 아래 그림과 같은 상태를 말합니다(붉은색이 좌측 상단).
grid_5.png

제한사항
grid의 행 길이 = 4
grid의 열 길이 = 4
1 ≤ grid의 원소 ≤ 2
1의 개수 = 8개, 2의 개수 = 8개인 경우만 입력으로 주어집니다.
1은 붉은색, 2는 파란색을 나타냅니다.
grid_6.png

입출력 예
grid	result
[[1,1,1,1],[2,1,2,2],[2,2,2,1],[1,1,2,2]]	5
[[1,1,1,2],[1,1,1,2],[2,2,2,1],[1,2,2,2]]	3
입출력 예 설명
입출력 예 #1

주어진 입력은 다음과 같습니다.

grid_7.png

문제에 주어진 예시와 같으며, 처음 상태로 만들기 위해 총 5번 행과 열을 이동해야 합니다.

입출력 예 #2

주어진 입력은 다음과 같습니다.

grid_8.png

다음과 같이 행, 열을 이동하면 3번 만에 처음 상태로 만들 수 있습니다.

grid_10.png